# -*- coding: utf-8 -*-
"""
Plot time series of positioner parameters.
"""

import os
import matplotlib.pyplot as plt
import numpy as np
from astropy.time import Time
import astropy.stats as stats
from astropy.table import Table

# common options
img_ext = '.png'
error_series_filename = 'fiterror' + img_ext
tick_period_days = 7
day_in_sec = 24*60*60

# plot definitions for parameter subplots
param_subplot_defs = [
    {'keys': ['FIT_ERROR_STATIC', 'FIT_ERROR_DYNAMIC'],
     'units': 'um RMS',
     'mult': 1000,
     'subplot': 1,
     'logscale': True,
     'equal_scales': True},
            
    {'keys': ['NUM_POINTS'],
     'units': 'USED IN FIT',
     'mult': 1,
     'subplot': 4,
     'logscale': False},
            
    {'keys': ['LENGTH_R1', 'LENGTH_R2'],
     'units': 'mm',
     'mult': 1,
     'subplot': 2,
     'logscale': False,
     'equal_scales': True},
            
    {'keys': ['OFFSET_X', 'OFFSET_Y'],
     'units': 'mm',
     'mult': 1,
     'subplot': 5,
     'logscale': False,
     'equal_scales': False},
            
    {'keys': ['OFFSET_T', 'OFFSET_P'],
     'units': 'deg',
     'mult': 1,
     'subplot': 6,
     'logscale': False,
     'equal_scales': False},
            
    {'keys': ['SCALE_T', 'SCALE_P'],
     'units': '',
     'mult': 1,
     'subplot': 3,
     'logscale': False,
     'equal_scales': True},
    ]

def plot_params(table, savepath, statics_during_dynamic):
    '''Plot time series of positioner parameters for a single positioner.
    
    Inputs:
        table    ... Astropy table as generated by fit_params, then reduced to
                     just the rows for a single POS_ID.
        
        savepath ... Where to save output plot file. Extension determines image
                     format.
        
        statics_during_dynamic ... Dict of static params used during the
                     dynamic params best-fit
        
    Outputs:
        The plot image file is saved to savepath. Also the savepath string is
        returned unaltered (for ease of tracking progress during multi-
        processing).
    '''
    fig = _init_plot()
    posid = table['POS_ID'][0]
    fig.subplots_adjust(wspace=.3, hspace=.3)
    times = table['DATE_SEC']
    tick_values, tick_labels = _ticks(times)
    n_pts = len(table)
    marker = ''
    for p in param_subplot_defs:
        plt.subplot(2, 3, p['subplot'])
        for key in p['keys']:
            ax_right = None
            if p['keys'].index(key) == 1:
                ax_right = plt.twinx()
                color = 'red'
                linestyle = '--'
                if n_pts == 1:
                    marker = '^'
            else:
                color = 'blue'
                linestyle = '-'
                if n_pts == 1:
                    marker = 'v'
            y = [val * p['mult'] for val in table[key]]#.tolist()]
            plt.plot(times, y, color=color, linestyle=linestyle, marker=marker)
            if not ax_right:
                ax_left = plt.gca()
            units = f' ({p["units"]})' if p['units'] else ''
            plt.ylabel(key + units, color=color)
            if p['logscale']:
                plt.yscale('log')
            if 'ylims' in p:
                plt.ylim(p['ylims'])
            if ax_right and p['equal_scales']:
                min_y = min(ax_left.get_ylim()[0], ax_right.get_ylim()[0])
                max_y = max(ax_left.get_ylim()[1], ax_right.get_ylim()[1])
                ax_left.set_ylim((min_y, max_y))
                ax_right.set_ylim((min_y, max_y))
            plt.xticks(tick_values, tick_labels, rotation=90, horizontalalignment='center', fontsize=8)
            plt.yticks(fontsize=8)
            if key == 'SCALE_P':
                s = statics_during_dynamic
                plt.text(min(plt.xlim()), min(plt.ylim()),
                         f' Using static params:\n'
                         f' LENGTH_R1 = {s["LENGTH_R1"]:>5.3f}, LENGTH_R2 = {s["LENGTH_R2"]:>5.3f}\n'
                         f' OFFSET_X = {s["OFFSET_X"]:>8.3f}, OFFSET_Y = {s["OFFSET_Y"]:>8.3f}\n'
                         f' OFFSET_T = {s["OFFSET_T"]:>8.3f}, OFFSET_P = {s["OFFSET_P"]:>8.3f}\n',
                         verticalalignment='bottom')
    analysis_date = table['ANALYSIS_DATE_DYNAMIC'][-1]
    title = f'{posid}'
    title += f'\nbest-fits to historical data'
    title += f'\nanalysis date: {analysis_date}'
    plt.suptitle(title)
    _save_and_close_plot(fig, savepath)
    return savepath

def plot_errors(table, savepath, bins=5):
    '''Plot time series of posparam fit errors, summing up at each time point
    for all postioners represented in table.
    
    Inputs:
        table    ... Astropy table as generated by fit_params, containing data
                     rows for multiple positioners.
        
        savepath ... Where to save output plot file. Extension determines image
                     format.
                     
        bins     ... int or sequence of scalars. Works like "bins: arg in numpy
                     histogram(). If bins is an int, it defines the number of
                     equal-width error bins to accumulate positioner counts. If
                     bins is a sequence, it defines the bin edges, including
                     the rightmost edge, allowing for non-uniform bin widths.
        
    Outputs:
        The plot image file is saved to savepath.
    '''
    fig = _init_plot()
    min_err = min(table['FIT_ERROR_DYNAMIC'])
    max_err = max(table['FIT_ERROR_DYNAMIC'])
    try:
        n_bins = int(bins)
        edges = np.linspace(min_err, max_err, n_bins + 1)
    except:
        n_bins = len(bins) - 1
        edges = np.array(bins)
    left_edges = edges[:-1]
    right_edges = edges[1:]
    centers = left_edges + np.diff(edges)/2
    time_min = min(table['DATE_SEC'])
    time_max = max(table['DATE_SEC'])
    period_duration = day_in_sec
    #periods = np.arange(time_min, time_max, step=period_duration)
    #periods = np.append(periods[1:], periods[-1] + period_duration)
    times = sorted(set(table['DATE_SEC']))
    periods = times
    posids = sorted(set(table['POS_ID']))
    subtables = {posid: table[table['POS_ID'] == posid] for posid in posids}
    errors = {}
    for period in periods:
        errors[period] = {}
        end = period
        start = end - period_duration
        for posid, subtable in subtables.items():
            selected = (start < subtable['DATE_SEC']) & (end >= subtable['DATE_SEC'])
            if any(selected):
                period_error = max(subtable[selected]['FIT_ERROR_DYNAMIC'])
                errors[period][posid] = period_error
        print(f'Errors binned for period {period} ({periods.index(period)} of {len(periods)})')
    passing = {}
    failing = {}
    for ceiling in right_edges:
        passing[ceiling] = {}
        failing[ceiling] = {}
        for i in range(len(periods)): 
            period = periods[i]
            passing[ceiling][period] = set()
            failing[ceiling][period] = set()
            for posid in posids:
                if posid in errors[period]:
                    if errors[period][posid] <= ceiling:
                        passing[ceiling][period].add(str(posid))
                    else:
                        failing[ceiling][period].add(str(posid))
                elif i > 0:
                    previous = periods[i-1]
                    previously_passed = posid in passing[ceiling][previous]
                    previously_failed = posid in failing[ceiling][previous]
                    if previously_passed:
                        passing[ceiling][period].add(posid)
                    elif previously_failed:
                        failing[ceiling][period].add(posid)
                    else:
                        pass # positioner not measured yet by this period
                else:
                    pass # positioner not measured yet in first period
        print(f'Pass/fails binned for ceiling {ceiling} ({right_edges.tolist().index(ceiling):.3f} of {len(right_edges)})')
    passing_counts = {}
    failing_counts = {}
    total_known = {}
    passing_fracs = {}
    failing_fracs = {}
    for ceiling in right_edges:
        passing_counts[ceiling] = []
        failing_counts[ceiling] = []
        for period in periods:
            n_pass = len(passing[ceiling][period])
            n_fail = len(failing[ceiling][period])
            passing_counts[ceiling].append(n_pass)
            failing_counts[ceiling].append(n_fail)
        passing_counts[ceiling] = np.array(passing_counts[ceiling])
        failing_counts[ceiling] = np.array(failing_counts[ceiling])
        total_known[ceiling] = passing_counts[ceiling] + failing_counts[ceiling]
        passing_fracs[ceiling] = passing_counts[ceiling] / total_known[ceiling]
        failing_fracs[ceiling] = failing_counts[ceiling] / total_known[ceiling]
    plt.subplot(2,2,1)
    _plot_error_series(periods, passing_counts, 'NUM PASSING')
    plt.subplot(2,2,2)
    _plot_error_series(periods, failing_counts, 'NUM FAILING')
    plt.subplot(2,2,3)
    _plot_error_series(periods, passing_fracs, 'FRACTION PASSING')
    plt.subplot(2,2,4)
    _plot_error_series(periods, failing_fracs, 'FRACTION FAILING')
    _save_and_close_plot(fig, savepath)
    return errors, passing_counts, failing_counts, total_known, passing_fracs, failing_fracs
    
def read(path):
    '''Reads in data for plotting, from csv files generated by fit_posparams.
    Returns astropy tables representing "merged" data set and "dynamic".'''
    if os.path.exists(path):
        merged = Table.read(path, format='csv')
        dynamic_path = path.split('merged.csv')[0] + 'dynamic.csv'
        if os.path.exists(dynamic_path):
            dynamic = Table.read(dynamic_path, format='csv')
        else:
            dynamic = None
            print('No "dynamic" results file found to match the "merged". This ' +
              'isn\'t catastrophic, but limits some information available to plot.')
    else:
        print('File not found: ' + path)
    if 'DATA_END_DATE_SEC' in merged.columns: # column not present in 2020-04-15 batch run data
        merged['DATE_SEC'] = merged['DATA_END_DATE_SEC']
    else:
        merged['DATE_SEC'] = Time(merged['DATA_END_DATE']).unix
    return merged, dynamic

def _init_plot():
    '''Internal common plot initialization function. Returns figure handle.'''
    plt.ioff()
    fig = plt.figure(figsize=(20,10), dpi=150)
    plt.clf()
    return fig
    
def _save_and_close_plot(fig, savepath):
    '''Internal common plot saving and closing function. Argue the figure
    handle to close, and the path where to save the image. Extension determines
    image format.'''
    plt.savefig(savepath, bbox_inches='tight')
    plt.close(fig)

def _plot_error_series(x, y, ylabel=''):
    '''Internal common plotting for error series. x is vector of dates in
    seconds since epoch. y is dict with keys = error ceilings and values =
    vectors of some count or fraction to be plotted. ylabel is self-explanatory.
    '''
    for ceiling, counts in y.items():
        plt.plot(x, counts, label=f'fit err <= {ceiling:5.3f}')
    tick_values, tick_labels = _ticks(x)
    plt.xticks(tick_values, tick_labels, rotation=90, horizontalalignment='center', fontsize=8)
    plt.ylabel(ylabel)
    plt.legend()
    
def _ticks(times):
    '''Internal common function to generate tick values and labels, given a
    vector of dates in seconds since epoch.'''
    tick_values = np.arange(times[0], times[-1]+day_in_sec, tick_period_days*day_in_sec)
    tick_labels = [Time(t, format='unix', out_subfmt='date').iso for t in tick_values]
    return tick_values, tick_labels
   