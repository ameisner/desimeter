#!/usr/bin/env python

import argparse
import sys,os
import numpy as np
import fitsio

from desimeter.log import get_logger
from desimeter.fieldmodel import FieldModel
from desimeter.transform.gfa2fp import fp2gfa
from desimeter.time import mjd2lst

parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                     description="""Fit guide star catalog to derive a field model (pointing, field rotation, scale)""")
parser.add_argument('-i','--infile', type = str, default = None, required = True,
                    help = 'path to a GFA catalog file, fits or csv, like ""')
parser.add_argument('-o','--outfile', type = str, default = None, required = True,
                    help = 'path to output json file with transformation parameters')
parser.add_argument('--fits-header', type = str, default = None,
                    help = 'path to file with fits header to read time and sky coordinates')
parser.add_argument('--plot', action = 'store_true')
parser.add_argument('--save-plot', type=str, default=None,
                    help='Base filename for plots')
parser.add_argument('--gfa-image', type=str, default=None,
                    help='Path to reduced GFA image, for plotting')
parser.add_argument('--cat', '--catalog', dest='cat', type=str, default=None,
                    help='Output catalog filename')

args  = parser.parse_args()
log   = get_logger()

fm = FieldModel()

if args.fits_header:
    header  = fitsio.read_header(args.fits_header,0)
else:
    header = fitsio.read_header(args.infile, 'GUIDER')

if not "TARGTRA" in header :
    log.warning("no TARGTRA in header of HDU 0, try HDU 1")
    header  = fitsio.read_header(args.fits_header,1)
    if not "TARGTRA" in header :
        log.error("no TARGTRA in headers of HDU 0 or 1 of file {}".format(args.fits_header))
        sys.exit(12)

fm.ra  = header["TARGTRA"]
fm.dec = header["TARGTDEC"]
fm.expid = header["EXPID"]
focus_terms = header['FOCUS'].split(',')
# The FOCUS header has comma-separated floats.
fm.hexrot_deg = float(focus_terms[5])/3600.
fm.adc1 = header["ADC1PHI"]
fm.adc2 = header["ADC2PHI"]

catalog = fm.read_guide_stars_catalog(args.infile)

# MJD and LST are needed for sky transform
fm.mjd = np.mean(catalog["mjd_obs"])
fm.lst = mjd2lst(fm.mjd)
fm.fit_tancorr(catalog)

# save it
with open(args.outfile, 'w') as file:
    file.write(fm.tojson())
print("wrote",args.outfile)

if args.cat:
    t=catalog
    xgfa=t["xcentroid"]
    ygfa=t["ycentroid"]
    pet=t["petal_loc"]
    xfp,yfp = fm.all_gfa2fp(xgfa,ygfa,pet)
    ra2,dec2=fm.fp2radec(xfp,yfp)
    t['fit_fx'] = xfp
    t['fit_fy'] = yfp
    t['fit_ra'] = ra2
    t['fit_dec'] = dec2
    ra=t["ra_gaia"]
    dec=t["dec_gaia"]
    t['fit_gaia_fx'] = np.zeros(len(t), np.float32)
    t['fit_gaia_fy'] = np.zeros(len(t), np.float32)
    t['fit_gaia_x'] = np.zeros(len(t), np.float32)
    t['fit_gaia_y'] = np.zeros(len(t), np.float32)
    # Skip chips missing GFA metrology
    ii=(xfp!=0)
    t = t[ii]
    cams = np.unique(t['camera'])
    for cam in cams:
        I = np.flatnonzero(t['camera'] == cam)
        petal = t["petal_loc"][I[0]]
        gfx,gfy = fm.radec2fp(t['ra_gaia'][I], t['dec_gaia'][I])
        gx,gy = fp2gfa(petal, gfx, gfy)
        t['fit_gaia_fx'][I] = gfx
        t['fit_gaia_fy'][I] = gfy
        t['fit_gaia_x'][I] = gx
        t['fit_gaia_y'][I] = gy
    t.write(args.cat, format='fits', overwrite=True)

if args.plot or args.save_plot:
    import matplotlib.pyplot as plt
    import matplotlib as mpl

    t=catalog
    xgfa=t["xcentroid"]
    ygfa=t["ycentroid"]
    dxgfa=t["dxcentroid"]
    dygfa=t["dycentroid"]
    pet=t["petal_loc"]

    # re-read the model to also test the I/O
    with open(args.outfile) as file :
        fm = FieldModel.fromjson(file.read())

    xfp,yfp = fm.all_gfa2fp(xgfa,ygfa,pet)
    ra2,dec2=fm.fp2radec(xfp,yfp)

    ra=t["ra_gaia"]
    dec=t["dec_gaia"]

    ii=(xfp!=0)
    dy=dec2[ii]-dec[ii]
    dx=(ra2[ii]-ra[ii])*np.cos(dec[ii]/180*np.pi)
    dr2=dx**2+dy**2
    rms=np.sqrt(np.mean(dr2))
    print("rms (Gaia RA,Dec - Measurement) = {:3.2f} arcsec".format(rms*3600.))
    rmeds=np.sqrt(np.median(dr2))
    print("r[median]s (Gaia RA,Dec - Measurement) = {:3.2f} arcsec".format(rmeds*3600.))

    fig = plt.figure("sky")
    ax = fig.subplots()
    ax.set_aspect(1. / np.cos(np.deg2rad(np.mean(dec))))
    plt.plot(ra,dec,"o",label="Gaia")
    plt.plot(ra2,dec2,"x",label="Measurements")
    xl,xh = plt.xlim()
    plt.xlim(xh,xl)
    plt.xlabel("RA (deg)")
    plt.ylabel("Dec (deg)")
    plt.legend()
    if args.save_plot:
        plt.savefig(args.save_plot + '1.png')
    else:
        plt.show()

    cams = np.unique(t['camera'])
    for cam in cams:
        I = np.flatnonzero(t['camera'] == cam)
        xx = xfp[I]
        # Skip chips missing GFA metrology
        if np.all(xx == 0.):
            continue
        plt.clf()
        ax = fig.subplots()
        ax.set_aspect(1. / np.cos(np.deg2rad(np.mean(dec))))
        plt.plot(ra[I], dec[I], 'b.')
        plt.quiver(ra[I], dec[I], ra2[I]-ra[I], dec2[I]-dec[I],
                   label='Measurements - Gaia',
                   angles='xy', scale_units='xy', scale=0.01)
        # GFA physical CCD size
        H,W = 1032,2048
        xx = np.array([1, 1, W, W, 1])
        yy = np.array([1, H, H, 1, 1])
        petal = pet[I[0]]
        x_c,y_c = fm.all_gfa2fp(xx, yy, np.zeros(len(xx),int) + petal)
        ra_c,dec_c = fm.fp2radec(x_c,y_c)
        plt.plot(ra_c, dec_c, 'k-')
        xl,xh = plt.xlim()
        plt.xlim(xh,xl)
        plt.xlabel("RA (deg)")
        plt.ylabel("Dec (deg)")
        plt.legend()
        if args.save_plot:
            plt.savefig(args.save_plot + '2-%s.png' % cam)
        else:
            plt.show()

        plt.clf()
        fig, ax = plt.subplots()
        plt.plot(xgfa[I], ygfa[I], 'b.')
        # error ellipse exaggeration
        EX = 10.
        for x,y,dx,dy in zip(xgfa[I], ygfa[I], dxgfa[I], dygfa[I]):
            e = mpl.patches.Ellipse((x,y), width=EX*dx*2., height=EX*dy*2.)
            ax.add_artist(e)
        gfx,gfy = fm.radec2fp(ra[I], dec[I])
        gx,gy = fp2gfa(petal, gfx, gfy)
        plt.quiver(xgfa[I], ygfa[I], xgfa[I]-gx, ygfa[I]-gy,
                   label='Measurements - Gaia',
                   angles='xy', scale_units='xy', scale=0.01)
        plt.plot(xx, yy, 'k-')
        m = 20
        plt.axis([1-m, W+m, 1-m, H+m])
        plt.axis('equal')
        plt.xlabel("GFA x (pixels)")
        plt.ylabel("GFA y (pixels)")
        plt.legend()
        if args.save_plot:
            plt.savefig(args.save_plot + '3-%s.png' % cam)
        else:
            plt.show()

        if args.gfa_image:
            img = fitsio.read(args.gfa_image, ext=cam)
            plt.clf()
            fig, axis = plt.subplots()
            mn,mx = np.percentile(img.ravel(), [50,98])
            plt.imshow(img, interpolation='nearest', origin='lower',
                       cmap='gray', vmin=mn, vmax=mx)
            ax = plt.axis()
            plt.plot(xgfa[I], ygfa[I], 'r*', ms=20, mec='r', mfc='none', mew=1)
            # error ellipse exaggeration
            # EX = 10.
            # for x,y,dx,dy in zip(xgfa[I], ygfa[I], dxgfa[I], dygfa[I]):
            #     e = mpl.patches.Ellipse((x,y), width=EX*dx*2., height=EX*dy*2.,
            #                             ec='red', fc='none')
            #     axis.add_artist(e)
            # gfx,gfy = fm.radec2fp(ra[I], dec[I])
            # gx,gy = fp2gfa(petal, gfx, gfy)
            # plt.quiver(xgfa[I], ygfa[I], xgfa[I]-gx, ygfa[I]-gy,
            #            label='Measurements - Gaia',
            #            angles='xy', scale_units='xy', scale=0.01)
            plt.axis(ax)
            plt.xlabel("GFA x (pixels)")
            plt.ylabel("GFA y (pixels)")
            #plt.legend()
            plt.title('GFA expid %i, %s: pixel space'% (header['EXPID'], cam))
            if args.save_plot:
                plt.savefig(args.save_plot + '4-%s.png' % cam)
            else:
                plt.show()

            gfx,gfy = fm.radec2fp(ra[I], dec[I])
            gx,gy = fp2gfa(petal, gfx, gfy)
            dx,dy = xgfa[I]-gx, ygfa[I]-gy
            dists = np.hypot(dx,dy)
            print('Median distance: %.2f pix' % np.median(dists))
            print('Largest differences:', ', '.join(['%.1f' % d for d in np.sort(dists)[-10:]]), 'pix')
            sigx = dx / dxgfa[I]
            sigy = dy / dygfa[I]
            sig = np.hypot(sigx, sigy)
            print('Largest differences:', ', '.join(['%.1f' % d for d in np.sort(sig)[-10:]]), 'sigmas')
            Iworst = np.argsort(sig)[-10:]
            print('Worst S/N: pix differences:', ', '.join(['%.1f' % d for d in dists[Iworst]]))
            print('Pixel uncertainties x:', ', '.join(['%.3f' % d for d in dxgfa[I[Iworst]]]))
            print('Pixel uncertainties y:', ', '.join(['%.3f' % d for d in dygfa[I[Iworst]]]))
                
            plt.clf()
            plt.semilogy(dists, sig, 'b.')
            plt.xlabel('Pixel offsets (pixels)')
            plt.ylabel('Pixel offsets / Measured position uncertainty (sigmas)')
            if args.save_plot:
                plt.savefig(args.save_plot + '6-%s.png' % cam)
            else:
                plt.show()

            
    plt.clf()
    for cam in cams:
        I = np.flatnonzero(t['camera'] == cam)
        cosdec = np.cos(np.deg2rad(np.mean(dec)))
        # FIXME
        dist = np.hypot((ra2[I] - ra[I])*cosdec, dec2[I] - dec[I])
        dist *= 3600.
        plt.hist(dist, range=(0,2), bins=50, histtype='step', label=cam)
    plt.xlabel('Match distance (arcsec)')
    plt.legend()
    if args.save_plot:
        plt.savefig(args.save_plot + '5.png')
    else:
        plt.show()
