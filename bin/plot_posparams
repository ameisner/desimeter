#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Plots fiber positioner parameters as best-fit by fit_posparams. Also plots
cumulative positioner errors over time, as calculated when performing those
best-fits.
"""

# command line argument parsing
import argparse
import math
parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument('-i', '--infiles', type=str, required=True, nargs='*',
                    help='path to input csv file(s) containing results from fit_posparams. ' \
                         'Regex ok (like M*_paramfits.csv). Multiple file args also ok (like ' \
                         'M0001_paramfis.csv M0002_paramfits.csv M01*.csv)')
parser.add_argument('-o', '--outdir', type=str, required=True,
                    help='path to directory where to save output plot files')
parser.add_argument('-np', '--n_processes_max', type=int, default=None,
                    help='max number of processors to use')
parser.add_argument('-q', '--quiet', action='store_true',
                    help='reduce verbosity of print outs at terminal')
parser.add_argument('-t', '--test_mode', action='store_true',
                    help='test mode, only plots results for the first positioner')
parser.add_argument('-sb', '--skip_bestfits', action='store_true',
                    help='skip generating plot of best-fit results for each positioner')
parser.add_argument('-sp', '--skip_passfail', action='store_true',
                    help='skip generating single plot binning historical pass/fail for all positioners (also saves bins as json)')
parser.add_argument('-b', '--bins', default=[0, 0.05, 0.1, 0.25, 0.5, .75, 1.0, math.inf],
                    help='set error bins, int or sequence, works approx like "bins" arg of numpy.hist() function (c.f. desimeter/posparams/plotter.py)')
parser.add_argument('-d', '--dynamic_passfail', action='store_true',
                    help='uses "dynamic" best-fit error (variable SCALE_T and SCALE_P) for pass/fail binning')
args = parser.parse_args()

# proceed with the rest
import os
import multiprocessing
import time
import json
import gzip
import glob
from astropy.table import Table
from astropy.table import vstack

# imports below require <path to desimeter>/py' to be added to system PYTHONPATH. 
import desimeter.posparams.plotter as plotter
import desimeter.posparams.fitter as fitter

# paths
infiles = []
for s in args.infiles:
    these = glob.glob(s)
    infiles.extend(these)
infiles = [os.path.realpath(p) for p in infiles]
save_dir = os.path.realpath(args.outdir)
if not os.path.isdir(save_dir):
    os.path.os.makedirs(save_dir)
    
# read in data tables and stack into one
tables = []
for path in infiles:
    if 'csv' in os.path.splitext(path)[-1]:
        this_table = Table.read(path, format='csv')
        tables += [this_table]
table = vstack(tables)
table.sort('POS_ID', 'DATA_END_DATE_SEC')
analysis_timestamp = min(table['ANALYSIS_DATE_STATIC'])

if not args.skip_passfail:
    mode = 'dynamic' if args.dynamic_passfail else 'static'
    prefix = os.path.join(save_dir, 'pf_' + mode)
    plot_path = prefix + plotter.img_ext
    binned = plotter.bin_errors(table, bins=args.bins, mode=mode)
    title = 'POSITIONER PASS/FAIL COUNTS\n'
    title += f'errors calculated by best-fit of {mode} calibration parameters\n'
    title += f'best-fits analysis date: {analysis_timestamp}'
    plotter.plot_passfail(binned, savepath=plot_path, title=title)
    binned_path = prefix + '.json.gzip'
    with gzip.open(binned_path, 'wt', encoding='ascii') as zipfile:
        json.dump(binned, zipfile)
    print(f'Pass/fail binned data saved to: {binned_path}')

if __name__ == '__main__' and not args.skip_bestfits:
    posids = sorted(set(table['POS_ID']))
    num_posids = len(posids)
    num_plots = num_posids if not args.test_mode else 1
    posids_to_plot = [posids[i] for i in range(num_plots)]
    mp_results = {}
    with multiprocessing.Pool(processes=args.n_processes_max) as pool:
        for posid in posids_to_plot:
            subtable = table[table['POS_ID'] == posid]
            some_row = subtable[0]
            statics_during_dynamic = {key:some_row[key + '_DYNAMIC'] for key in fitter.static_keys}
            save_path = os.path.join(save_dir, posid + '_paramfits' + plotter.img_ext)
            save_path = os.path.realpath(save_path)
            plot_args = (subtable, save_path, statics_during_dynamic)
            mp_results[posid] = pool.apply_async(plotter.plot_params, args=plot_args)
            if not args.quiet:
                print(f'Plot job added: {posid}')
        while mp_results:
            completed = set()
            for posid, result in mp_results.items():
                if result.ready():
                    completed.add(posid)
                    if not args.quiet:
                        print(f'Plot saved: {result.get()}')
            for posid in completed:
                del mp_results[posid]
            time.sleep(0.05)
